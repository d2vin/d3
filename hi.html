<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF Overlay - Fixed Size, Fixed Position, No Bars (Final)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CRITICAL ADDITION: Reset default browser margins/paddings */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Hide scrollbars for the whole page */
        }

        body {
            font-family: 'Inter', sans-serif;
            cursor: none; /* Hide default cursor */
            /* This background color will show if the browser window is larger than the fixed GIF dimensions */
            background-color: #000;
            position: relative; /* Make body the positioning context for absolute children */
        }

        .gif-container {
            position: absolute; /* Pin it to a fixed position relative to the body */
            top: 0;             /* Top-left corner of the viewport */
            left: 0;            /* Top-left corner of the viewport */

            /* IMPORTANT: Set fixed dimensions to your GIF's actual intrinsic resolution.
               Assuming your GIFs are 1920x1080. ADJUST THESE VALUES if different. */
            width: 1137px; /* Example GIF width */
            height: 796px; /* Example GIF height */
            overflow: hidden; /* Ensures any GIF content exceeding these dimensions is clipped */
        }

        .full-screen-gif {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* CRITICAL: `object-fit: cover;` ensures the GIF always fills its 1920x1080 container,
               cropping if aspect ratios differ, thus preventing bars. */
            object-fit: cover;
        }

        #topGif {
            z-index: 1;
            pointer-events: none; /* Allows mouse events to pass through */

            /* Referencing the SVG clip-path */
            clip-path: url(#clipJaggedCircle);
            -webkit-clip-path: url(#clipJaggedCircle);

            transition: clip-path 0.05s ease-out, opacity 0.2s ease-out;
            opacity: 0;
            image-rendering: pixelated;
        }

        #bottomGif {
            z-index: 0;
            image-rendering: pixelated;
        }

        #clipPathSvg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Needed for clip-path to scale correctly within gif-container */
            height: 100%; /* Needed for clip-path to scale correctly within gif-container */
            pointer-events: none; /* Crucial: make SVG non-interactive */
            z-index: 2; /* SVG is above GIFs for clipping */
        }

        /* Styles for the FIXED invisible hitbox button */
        #fixedHitboxButtonRed {
            position: absolute; /* Positioned relative to the body/viewport */
            width: 80px;   /* 2 * 40px radius = diameter */
            height: 80px;  /* 2 * 40px radius = diameter */
            border-radius: 50%; /* Make it circular */
            background-color: transparent; /* Makes it invisible inside */

            /* RED OUTLINE FOR DEBUGGING / VISIBILITY */
            /* border: 1px solid red; */

            /* Positioning the center of the hitbox at X=1080px, Y=380px */
            /* These coordinates are relative to the VIEPORT. Since the GIF is also fixed to 0,0,
               these coordinates are also effectively relative to the GIF's top-left. */
            left: 660px; /* Adjusted to 800px as per your last input */
            top: 270px;  /* Adjusted to 280px as per your last input */
            transform: translate(-50%, -50%); /* Centers the div on the specified left/top coordinates */

            z-index: 4; /* Ensure it's above everything else */
            pointer-events: auto; /* Crucial: allow this element to receive clicks */
            cursor: pointer; /* Give a visual cue that it's clickable */
        }

        /* Styles for the FIXED invisible hitbox button */
        #fixedHitboxButtonYellow {
            position: absolute; /* Positioned relative to the body/viewport */
            width: 60px;   /* 2 * 40px radius = diameter */
            height: 60px;  /* 2 * 40px radius = diameter */
            border-radius: 50%; /* Make it circular */
            background-color: transparent; /* Makes it invisible inside */

            /* RED OUTLINE FOR DEBUGGING / VISIBILITY */
            /* border: 1px solid red; */

            /* Positioning the center of the hitbox at X=1080px, Y=380px */
            /* These coordinates are relative to the VIEPORT. Since the GIF is also fixed to 0,0,
               these coordinates are also effectively relative to the GIF's top-left. */
            left: 470px; /* Adjusted to 800px as per your last input */
            top: 130px;  /* Adjusted to 280px as per your last input */
            transform: translate(-50%, -50%); /* Centers the div on the specified left/top coordinates */

            z-index: 4; /* Ensure it's above everything else */
            pointer-events: auto; /* Crucial: allow this element to receive clicks */
            cursor: pointer; /* Give a visual cue that it's clickable */
        }
    </style>
</head>
<body class="bg-black">
    <div id="gifContainer" class="gif-container">
        <img id="topGif" src="./color-backround.gif" alt="Top Layer GIF" class="full-screen-gif">
        <img id="bottomGif" src="./backround-museum.gif" alt="Bottom Layer GIF" class="full-screen-gif">
    </div>

    <svg id="clipPathSvg" width="0" height="0">
        <defs>
            <clipPath id="clipJaggedCircle">
                <path id="jaggedCirclePath" d="M0,0"></path>
            </clipPath>
        </defs>
    </svg>

    <div id="fixedHitboxButtonRed"></div>
    <div id="fixedHitboxButtonYellow"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gifContainer = document.getElementById('gifContainer');
            const topGif = document.getElementById('topGif');
            const bottomGif = document.getElementById('bottomGif');
            const jaggedCirclePath = document.getElementById('jaggedCirclePath');
            const fixedHitboxButtonRed = document.getElementById('fixedHitboxButtonRed');
            const fixedHitboxButtonYellow = document.getElementById('fixedHitboxButtonYellow');

            const cutoutRadiusPx = 40;
            const pixelSize = 5;

            // --- State variable for GIF toggle ---
            let isAltGifsActive = false; // False means default GIFs are active
            const defaultTopGifSrc = './color-backround.gif';
            const defaultBottomGifSrc = './backround-museum.gif';
            const altTopGifSrc = './yellowbackground.gif';
            const altBottomGifSrc = './redplanet1.gif';
            const altBottomGifSrc2 = './yellowplanet1.gif'; // Example alternate bottom GIF
            // ------------------------------------------

            // Function to generate a jagged circle SVG path
            function generateJaggedCirclePath(cx, cy, radius, pixelGridSize) {
                let pathData = ``;
                const numPoints = 64;
                const angleIncrement = (Math.PI * 2) / numPoints;

                let prevSnX = 0;
                let prevSnY = 0;

                for (let i = 0; i <= numPoints; i++) {
                    const angle = i * angleIncrement;
                    let targetX = cx + radius * Math.cos(angle);
                    let targetY = cy + radius * Math.sin(angle);

                    let snappedX = Math.round(targetX / pixelGridSize) * pixelGridSize;
                    let snappedY = Math.round(targetY / pixelGridSize) * pixelGridSize;

                    if (i === 0) {
                        pathData = `M${snappedX},${snappedY}`;
                    } else {
                        const dx = Math.abs(snappedX - prevSnX);
                        const dy = Math.abs(snappedY - prevSnY);

                        if (dx >= dy) {
                            pathData += `L${snappedX},${prevSnY} L${snappedX},${snappedY} `;
                        } else {
                            pathData += `L${prevSnX},${snappedY} L${snappedX},${snappedY} `;
                        }
                    }
                    prevSnX = snappedX;
                    prevSnY = snappedY;
                }
                pathData += `Z`;
                return pathData;
            }

            // Function to update the SVG path based on mouse position
            function updateClipPath(e) {
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                // Get the actual displayed rectangle of the bottom GIF
                const gifRect = bottomGif.getBoundingClientRect();

                // Calculate center for the jagged circle relative to the GIF's displayed area
                const relativeX = mouseX - gifRect.left;
                const relativeY = mouseY - gifRect.top;

                // Only update if mouse is within the visible GIF area
                if (mouseX >= gifRect.left && mouseX <= gifRect.right &&
                    mouseY >= gifRect.top && mouseY <= gifRect.bottom) {

                    const newPathData = generateJaggedCirclePath(relativeX, relativeY, cutoutRadiusPx, pixelSize);
                    jaggedCirclePath.setAttribute('d', newPathData);
                    topGif.style.opacity = 1;
                } else {
                    // Hide the cutout if mouse leaves the actual GIF
                    resetClipPath();
                }
            }

            // Function to reset the clip-path (hide the cutout)
            function resetClipPath() {
                jaggedCirclePath.setAttribute('d', generateJaggedCirclePath(0, 0, 0, pixelSize));
                topGif.style.opacity = 0;
            }

            // Add event listeners for mousemove and mouseleave to the GIF container
            gifContainer.addEventListener('mousemove', updateClipPath);
            gifContainer.addEventListener('mouseleave', resetClipPath);

            // Add mousemove listener to the fixedHitboxButtonRed as well
            fixedHitboxButtonRed.addEventListener('mousemove', updateClipPath);
            // Add mouseleave listener to the fixedHitboxButtonRed
            fixedHitboxButtonRed.addEventListener('mouseleave', resetClipPath);

            // Add mousemove listener to the fixedHitboxButtonYellow as well
            fixedHitboxButtonYellow.addEventListener('mousemove', updateClipPath);
            // Add mouseleave listener to the fixedHitboxButtonYellow
            fixedHitboxButtonYellow.addEventListener('mouseleave', resetClipPath);


            // --- MODIFIED CLICK LISTENER FOR TOGGLE ---
            fixedHitboxButtonRed.addEventListener('click', () => {
                if (isAltGifsActive) {
                    // Currently showing alt GIFs, switch back to default
                    console.log('Switching back to default GIFs.');
                    topGif.src = defaultTopGifSrc;
                    bottomGif.src = defaultBottomGifSrc;
                } else {
                    // Currently showing default GIFs, switch to alt
                    console.log('Switching to alternate GIFs.');
                    topGif.src = altTopGifSrc;
                    bottomGif.src = altBottomGifSrc;
                }
                // Flip the state
                isAltGifsActive = !isAltGifsActive;
                // Always reset cutout after GIF change to prevent weird artifacts
                resetClipPath();
            });

            // --- MODIFIED CLICK LISTENER FOR TOGGLE ---
            fixedHitboxButtonYellow.addEventListener('click', () => {
                if (isAltGifsActive) {
                    // Currently showing alt GIFs, switch back to default
                    console.log('Switching back to default GIFs.');
                    topGif.src = defaultTopGifSrc;
                    bottomGif.src = defaultBottomGifSrc;
                } else {
                    // Currently showing default GIFs, switch to alt
                    console.log('Switching to alternate GIFs.');
                    topGif.src = altTopGifSrc;
                    bottomGif.src = altBottomGifSrc2;
                }
                // Flip the state
                isAltGifsActive = !isAltGifsActive;
                // Always reset cutout after GIF change to prevent weird artifacts
                resetClipPath();
            });
            // ------------------------------------------

            // Set initial state (hidden cutout)
            resetClipPath();

            // Optional: Handle window resize. Resets the mask, it will re-appear on mousemove.
            window.addEventListener('resize', resetClipPath);

            // Fallback for GIF loading errors (optional)
            const gifs = document.querySelectorAll('.full-screen-gif');
            gifs.forEach(gif => {
                gif.onerror = () => {
                    console.error('Failed to load GIF:', gif.src);
                    gif.src = `https://placehold.co/1920x1080/000000/FFFFFF?text=GIF+Loading+Failed`;
                };
            });
        });
    </script>
</body>
</html>